/* soapStub.h
   Generated by gSOAP 2.8.10 from XMLAMethods.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20810
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_UserDataProp
#define SOAP_TYPE_UserDataProp (36)
typedef struct UserPropStruct UserDataProp;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xmlns__PropertyList
#define SOAP_TYPE_xmlns__PropertyList (10)
/* xmlns:PropertyList */
class SOAP_CMAC xmlns__PropertyList
{
public:
	char *Authentication;	/* optional element of type xsd:string */
	int LocaleIdentifier;	/* required element of type xsd:int */
	char *Content;	/* optional element of type xsd:string */
	char *Format;	/* optional element of type xsd:string */
	char *Catalog;	/* optional element of type xsd:string */
	char *DataSourceInfo;	/* optional element of type xsd:string */
	char *AxisFormat;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_xmlns__PropertyList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__PropertyList() { xmlns__PropertyList::soap_default(NULL); }
	virtual ~xmlns__PropertyList() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Properties
#define SOAP_TYPE_xmlns__Properties (11)
/* xmlns:Properties */
class SOAP_CMAC xmlns__Properties
{
public:
	xmlns__PropertyList PropertyList;	/* required element of type xmlns:PropertyList */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_xmlns__Properties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Properties() { xmlns__Properties::soap_default(NULL); }
	virtual ~xmlns__Properties() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__RestrictionList
#define SOAP_TYPE_xmlns__RestrictionList (12)
/* xmlns:RestrictionList */
class SOAP_CMAC xmlns__RestrictionList
{
public:
	char *PropertyName;	/* optional element of type xsd:string */
	char *CATALOG_USCORENAME;	/* optional element of type xsd:string */
	char *CUBE_USCORENAME;	/* optional element of type xsd:string */
	char *HIERARCHY_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *MEMBER_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *LEVEL_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *TREE_USCOREOP;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_xmlns__RestrictionList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__RestrictionList() { xmlns__RestrictionList::soap_default(NULL); }
	virtual ~xmlns__RestrictionList() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Restrictions
#define SOAP_TYPE_xmlns__Restrictions (13)
/* xmlns:Restrictions */
class SOAP_CMAC xmlns__Restrictions
{
public:
	xmlns__RestrictionList RestrictionList;	/* required element of type xmlns:RestrictionList */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_xmlns__Restrictions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Restrictions() { xmlns__Restrictions::soap_default(NULL); }
	virtual ~xmlns__Restrictions() { }
};
#endif

#ifndef SOAP_TYPE_row
#define SOAP_TYPE_row (15)
/* row */
struct row
{
public:
	char *CATALOG_USCORENAME;	/* optional element of type xsd:string */
	char *DESCRIPTION;	/* optional element of type xsd:string */
	char *CUBE_USCORENAME;	/* optional element of type xsd:string */
	char *CUBE_USCORETYPE;	/* optional element of type xsd:string */
	char *DIMENSION_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *DIMENSION_USCORENAME;	/* optional element of type xsd:string */
	char *DIMENSION_USCORECAPTION;	/* optional element of type xsd:string */
	char *DIMENSION_USCORETYPE;	/* optional element of type xsd:string */
	char *DIMENSION_USCOREORDINAL;	/* optional element of type xsd:string */
	char *DIMENSION_USCORECARDINALITY;	/* optional element of type xsd:string */
	char *DEFAULT_USCOREHIERARCHY;	/* optional element of type xsd:string */
	char *HIERARCHY_USCORENAME;	/* optional element of type xsd:string */
	char *HIERARCHY_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *HIERARCHY_USCORECAPTION;	/* optional element of type xsd:string */
	char *HIERARCHY_USCORECARDINALITY;	/* optional element of type xsd:string */
	char *DEFAULT_USCOREMEMBER;	/* optional element of type xsd:string */
	char *ALL_USCOREMEMBER;	/* optional element of type xsd:string */
	char *MEASURE_USCORENAME;	/* optional element of type xsd:string */
	char *MEASURE_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *MEASURE_USCORECAPTION;	/* optional element of type xsd:string */
	char *MEASURE_USCOREAGGREGATOR;	/* optional element of type xsd:string */
	char *DATA_USCORETYPE;	/* optional element of type xsd:string */
	char *NUMERIC_USCOREPRECISION;	/* optional element of type xsd:string */
	char *NUMERIC_USCORESCALE;	/* optional element of type xsd:string */
	char *LEVEL_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *LEVEL_USCORENUMBER;	/* optional element of type xsd:string */
	char *MEMBER_USCOREORDINAL;	/* optional element of type xsd:string */
	char *MEMBER_USCORENAME;	/* optional element of type xsd:string */
	char *MEMBER_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *MEMBER_USCORETYPE;	/* optional element of type xsd:string */
	char *MEMBER_USCORECAPTION;	/* optional element of type xsd:string */
	char *CHILDREN_USCORECARDINALITY;	/* optional element of type xsd:string */
	char *PARENT_USCORELEVEL;	/* optional element of type xsd:string */
	char *PARENT_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *PARENT_USCORECOUNT;	/* optional element of type xsd:string */
	char *TREE_USCOREOP;	/* optional element of type xsd:string */
	char *DEPTH;	/* optional element of type xsd:string */
	char *LEVEL_USCORENAME;	/* optional element of type xsd:string */
	char *LEVEL_USCORECAPTION;	/* optional element of type xsd:string */
	char *LEVEL_USCORECARDINALITY;	/* optional element of type xsd:string */
	char *LEVEL_USCORETYPE;	/* optional element of type xsd:string */
	char *PROPERTY_USCORENAME;	/* optional element of type xsd:string */
	char *PROPERTY_USCORECAPTION;	/* optional element of type xsd:string */
	char *PROPERTY_USCORETYPE;	/* optional element of type xsd:string */
	char *PropertyName;	/* optional element of type xsd:string */
	char *PropertyDescription;	/* optional element of type xsd:string */
	char *PropertyType;	/* optional element of type xsd:string */
	char *PropertyAccessType;	/* optional element of type xsd:string */
	char *IsRequired;	/* optional element of type xsd:string */
	char *Value;	/* optional element of type xsd:string */
	char *DataSourceName;	/* optional element of type xsd:string */
	char *DataSourceDescription;	/* optional element of type xsd:string */
	char *DataSourceInfo;	/* optional element of type xsd:string */
	char *ProviderName;	/* optional element of type xsd:string */
	char *ProviderType;	/* optional element of type xsd:string */
	char *AuthenticationMode;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_xmlns__rows
#define SOAP_TYPE_xmlns__rows (14)
/* xmlns:rows */
class SOAP_CMAC xmlns__rows
{
public:
	int __size;	/* sequence of elements <row> */
	struct row *row;	/* optional element of type row */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xmlns__rows */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__rows() { xmlns__rows::soap_default(NULL); }
	virtual ~xmlns__rows() { }
};
#endif

#ifndef SOAP_TYPE_element__
#define SOAP_TYPE_element__ (20)
/* element */
struct element__
{
public:
	char *maxOccurs;	/* optional attribute of type xsd:string */
	char *minOccurs;	/* optional attribute of type xsd:string */
	char *name;	/* optional attribute of type xsd:string */
	char *type;	/* optional attribute of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_sequence_schema
#define SOAP_TYPE_sequence_schema (19)
/* sequence-schema */
struct sequence_schema
{
public:
	struct element__ xsd__element;	/* required element of type element */
};
#endif

#ifndef SOAP_TYPE_complexType_schema
#define SOAP_TYPE_complexType_schema (18)
/* complexType-schema */
struct complexType_schema
{
public:
	struct sequence_schema xsd__sequence;	/* required element of type sequence-schema */
};
#endif

#ifndef SOAP_TYPE_element_schema
#define SOAP_TYPE_element_schema (17)
/* element-schema */
class SOAP_CMAC element_schema
{
public:
	struct complexType_schema xsd__complexType;	/* required element of type complexType-schema */
	char *name;	/* optional attribute */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_element_schema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         element_schema() { element_schema::soap_default(NULL); }
	virtual ~element_schema() { }
};
#endif

#ifndef SOAP_TYPE_pattern
#define SOAP_TYPE_pattern (23)
/* pattern */
struct pattern
{
public:
	char *value;	/* optional attribute of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_restriction
#define SOAP_TYPE_restriction (22)
/* restriction */
struct restriction
{
public:
	char *base;	/* optional attribute of type xsd:string */
	struct pattern xsd__pattern;	/* required element of type pattern */
};
#endif

#ifndef SOAP_TYPE_simpleType
#define SOAP_TYPE_simpleType (21)
/* simpleType */
class SOAP_CMAC simpleType
{
public:
	char *name;	/* optional attribute */
	struct restriction xsd__restriction;	/* required element of type restriction */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_simpleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         simpleType() { simpleType::soap_default(NULL); }
	virtual ~simpleType() { }
};
#endif

#ifndef SOAP_TYPE_element
#define SOAP_TYPE_element (25)
/* element */
struct element
{
public:
	char *sql__field;	/* optional attribute of type xsd:string */
	char *minOccurs;	/* optional attribute of type xsd:string */
	char *name;	/* optional attribute of type xsd:string */
	char *type;	/* optional attribute of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_sequence
#define SOAP_TYPE_sequence (24)
/* sequence */
class SOAP_CMAC sequence
{
public:
	int __size;	/* sequence of elements <xsd:element> */
	struct element *xsd__element;	/* optional element of type element */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sequence() { sequence::soap_default(NULL); }
	virtual ~sequence() { }
};
#endif

#ifndef SOAP_TYPE_datasource_complexType
#define SOAP_TYPE_datasource_complexType (27)
/* datasource-complexType */
class SOAP_CMAC datasource_complexType
{
public:
	char *name;	/* optional attribute */
	sequence xsd__sequence;	/* required element of type sequence */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_datasource_complexType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         datasource_complexType() { datasource_complexType::soap_default(NULL); }
	virtual ~datasource_complexType() { }
};
#endif

#ifndef SOAP_TYPE_schema
#define SOAP_TYPE_schema (28)
/* schema */
class SOAP_CMAC schema
{
public:
	char *elementFormDefault;	/* optional attribute */
	char *targetNamespace;	/* optional attribute */
	char *xmlns;	/* optional attribute */
	element_schema xsd__element;	/* required element of type element-schema */
	simpleType xsd__simpleType;	/* required element of type simpleType */
	datasource_complexType xsd__complexType;	/* required element of type datasource-complexType */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_schema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         schema() { schema::soap_default(NULL); }
	virtual ~schema() { }
};
#endif

#ifndef SOAP_TYPE_root__
#define SOAP_TYPE_root__ (29)
/* root */
class SOAP_CMAC root__
{
public:
	char *xmlns;	/* optional attribute */
	schema xsd__schema;	/* required element of type schema */
	xmlns__rows __rows;
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_root__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         root__() { root__::soap_default(NULL); }
	virtual ~root__() { }
};
#endif

#ifndef SOAP_TYPE_cxmla__return
#define SOAP_TYPE_cxmla__return (30)
/* cxmla:return */
class SOAP_CMAC cxmla__return
{
public:
	root__ root;	/* required element of type root */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_cxmla__return */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         cxmla__return() { cxmla__return::soap_default(NULL); }
	virtual ~cxmla__return() { }
};
#endif

#ifndef SOAP_TYPE_cxmla__DiscoverResponse
#define SOAP_TYPE_cxmla__DiscoverResponse (31)
/* cxmla:DiscoverResponse */
class SOAP_CMAC cxmla__DiscoverResponse
{
public:
	cxmla__return cxmla__return__;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type cxmla:return */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_cxmla__DiscoverResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         cxmla__DiscoverResponse() { cxmla__DiscoverResponse::soap_default(NULL); }
	virtual ~cxmla__DiscoverResponse() { }
};
#endif

#ifndef SOAP_TYPE_UserPropStruct
#define SOAP_TYPE_UserPropStruct (32)
/* Transient type: */
struct UserPropStruct
{
public:
	const char *elementName;	/* transient */
	const char *value;	/* transient */
};
#endif

#ifndef SOAP_TYPE_arrayUserProp
#define SOAP_TYPE_arrayUserProp (37)
/* arrayUserProp */
class SOAP_CMAC arrayUserProp
{
public:
	int __size;	/* sequence of elements <-array> */
	struct UserPropStruct *__array;
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_arrayUserProp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         arrayUserProp() { arrayUserProp::soap_default(NULL); }
	virtual ~arrayUserProp() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Cube
#define SOAP_TYPE_xmlns__Cube (39)
/* xmlns:Cube */
class SOAP_CMAC xmlns__Cube
{
public:
	char *CubeName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_xmlns__Cube */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Cube() { xmlns__Cube::soap_default(NULL); }
	virtual ~xmlns__Cube() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__CubeInfo
#define SOAP_TYPE_xmlns__CubeInfo (40)
/* xmlns:CubeInfo */
class SOAP_CMAC xmlns__CubeInfo
{
public:
	xmlns__Cube Cube;	/* required element of type xmlns:Cube */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_xmlns__CubeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__CubeInfo() { xmlns__CubeInfo::soap_default(NULL); }
	virtual ~xmlns__CubeInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__UName
#define SOAP_TYPE_xmlns__UName (41)
/* xmlns:UName */
class SOAP_CMAC xmlns__UName
{
public:
	char *name;	/* optional attribute */
	char *UName;	/* optional element of type xsd:string */
	xmlns__UName();	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_xmlns__UName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__UName() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Caption
#define SOAP_TYPE_xmlns__Caption (45)
/* xmlns:Caption */
class SOAP_CMAC xmlns__Caption
{
public:
	char *name;	/* optional attribute */
	char *Caption;	/* optional element of type xsd:string */
	xmlns__Caption();	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_xmlns__Caption */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__Caption() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__LName
#define SOAP_TYPE_xmlns__LName (47)
/* xmlns:LName */
class SOAP_CMAC xmlns__LName
{
public:
	char *name;	/* optional attribute */
	char *LName;	/* optional element of type xsd:string */
	xmlns__LName();	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_xmlns__LName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__LName() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__LNum
#define SOAP_TYPE_xmlns__LNum (49)
/* xmlns:LNum */
class SOAP_CMAC xmlns__LNum
{
public:
	char *name;	/* optional attribute */
	char *LNum;	/* optional element of type xsd:string */
	xmlns__LNum();	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_xmlns__LNum */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__LNum() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__DisplayInfo
#define SOAP_TYPE_xmlns__DisplayInfo (51)
/* xmlns:DisplayInfo */
class SOAP_CMAC xmlns__DisplayInfo
{
public:
	char *name;	/* optional attribute */
	char *DisplayInfo;	/* optional element of type xsd:string */
	xmlns__DisplayInfo();	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_xmlns__DisplayInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__DisplayInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__ParentUniqueName
#define SOAP_TYPE_xmlns__ParentUniqueName (53)
/* xmlns:ParentUniqueName */
class SOAP_CMAC xmlns__ParentUniqueName
{
public:
	char *name;	/* optional attribute */
	char *ParentUniqueName;	/* optional element of type xsd:string */
	xmlns__ParentUniqueName();	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_xmlns__ParentUniqueName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__ParentUniqueName() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__MemberName
#define SOAP_TYPE_xmlns__MemberName (55)
/* xmlns:MemberName */
class SOAP_CMAC xmlns__MemberName
{
public:
	char *name;	/* optional attribute */
	char *MEMBER_USCORENAME;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_xmlns__MemberName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__MemberName() { xmlns__MemberName::soap_default(NULL); }
	virtual ~xmlns__MemberName() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__MemberType
#define SOAP_TYPE_xmlns__MemberType (56)
/* xmlns:MemberType */
class SOAP_CMAC xmlns__MemberType
{
public:
	char *name;	/* optional attribute */
	char *MEMBER_USCORETYPE;	/* optional element of type xsd:string */
	xmlns__MemberType();	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_xmlns__MemberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__MemberType() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__HierarchyInfo
#define SOAP_TYPE_xmlns__HierarchyInfo (58)
/* xmlns:HierarchyInfo */
class SOAP_CMAC xmlns__HierarchyInfo
{
public:
	char *name;	/* optional attribute */
	xmlns__UName UName;	/* required element of type xmlns:UName */
	xmlns__Caption Caption;	/* required element of type xmlns:Caption */
	xmlns__LName LName;	/* required element of type xmlns:LName */
	xmlns__LNum LNum;	/* required element of type xmlns:LNum */
	xmlns__DisplayInfo DisplayInfo;	/* required element of type xmlns:DisplayInfo */
	xmlns__ParentUniqueName *PARENT_USCOREUNIQUE_USCORENAME;	/* optional element of type xmlns:ParentUniqueName */
	xmlns__MemberName *MEMBER_USCORENAME;	/* optional element of type xmlns:MemberName */
	xmlns__MemberType *MEMBER_USCORETYPE;	/* optional element of type xmlns:MemberType */
	arrayUserProp __userProp;
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_xmlns__HierarchyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__HierarchyInfo() { xmlns__HierarchyInfo::soap_default(NULL); }
	virtual ~xmlns__HierarchyInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__AxisInfo
#define SOAP_TYPE_xmlns__AxisInfo (62)
/* xmlns:AxisInfo */
class SOAP_CMAC xmlns__AxisInfo
{
public:
	int __size;	/* sequence of elements <HierarchyInfo> */
	xmlns__HierarchyInfo *HierarchyInfo;	/* optional element of type xmlns:HierarchyInfo */
	char *name;	/* optional attribute */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_xmlns__AxisInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__AxisInfo() { xmlns__AxisInfo::soap_default(NULL); }
	virtual ~xmlns__AxisInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__AxesInfo
#define SOAP_TYPE_xmlns__AxesInfo (64)
/* xmlns:AxesInfo */
class SOAP_CMAC xmlns__AxesInfo
{
public:
	int __size;	/* sequence of elements <AxisInfo> */
	xmlns__AxisInfo *AxisInfo;	/* optional element of type xmlns:AxisInfo */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_xmlns__AxesInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__AxesInfo() { xmlns__AxesInfo::soap_default(NULL); }
	virtual ~xmlns__AxesInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__ValueCellInfo
#define SOAP_TYPE_xmlns__ValueCellInfo (67)
/* xmlns:ValueCellInfo */
struct xmlns__ValueCellInfo
{
public:
	char *name;	/* optional attribute of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_xmlns__CellInfo
#define SOAP_TYPE_xmlns__CellInfo (66)
/* xmlns:CellInfo */
class SOAP_CMAC xmlns__CellInfo
{
public:
	struct xmlns__ValueCellInfo Value;	/* required element of type xmlns:ValueCellInfo */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_xmlns__CellInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__CellInfo() { xmlns__CellInfo::soap_default(NULL); }
	virtual ~xmlns__CellInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__OlapInfo
#define SOAP_TYPE_xmlns__OlapInfo (68)
/* xmlns:OlapInfo */
class SOAP_CMAC xmlns__OlapInfo
{
public:
	xmlns__CubeInfo CubeInfo;	/* required element of type xmlns:CubeInfo */
	xmlns__AxesInfo AxesInfo;	/* required element of type xmlns:AxesInfo */
	xmlns__CellInfo CellInfo;	/* required element of type xmlns:CellInfo */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_xmlns__OlapInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__OlapInfo() { xmlns__OlapInfo::soap_default(NULL); }
	virtual ~xmlns__OlapInfo() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Member
#define SOAP_TYPE_xmlns__Member (69)
/* xmlns:Member */
class SOAP_CMAC xmlns__Member
{
public:
	char *Hierarchy;	/* optional attribute */
	char *UName;	/* optional element of type xsd:string */
	char *Caption;	/* optional element of type xsd:string */
	char *LName;	/* optional element of type xsd:string */
	char *LNum;	/* optional element of type xsd:string */
	char *DisplayInfo;	/* optional element of type xsd:string */
	char *PARENT_USCOREUNIQUE_USCORENAME;	/* optional element of type xsd:string */
	char *MEMBER_USCORENAME;	/* optional element of type xsd:string */
	char *MEMBER_USCORETYPE;	/* optional element of type xsd:string */
	arrayUserProp __userProp;
	xmlns__Member();	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_xmlns__Member */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xmlns__Member() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Tuple
#define SOAP_TYPE_xmlns__Tuple (72)
/* xmlns:Tuple */
struct xmlns__Tuple
{
public:
	int __size;	/* sequence of elements <Member> */
	xmlns__Member *Member;	/* optional element of type xmlns:Member */
};
#endif

#ifndef SOAP_TYPE_xmlns__Tuples
#define SOAP_TYPE_xmlns__Tuples (71)
/* xmlns:Tuples */
class SOAP_CMAC xmlns__Tuples
{
public:
	int __size;	/* sequence of elements <Tuple> */
	struct xmlns__Tuple *Tuple;	/* optional element of type xmlns:Tuple */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_xmlns__Tuples */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Tuples() { xmlns__Tuples::soap_default(NULL); }
	virtual ~xmlns__Tuples() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Axis
#define SOAP_TYPE_xmlns__Axis (76)
/* xmlns:Axis */
struct xmlns__Axis
{
public:
	char *name;	/* optional attribute of type xsd:string */
	xmlns__Tuples Tuples;	/* required element of type xmlns:Tuples */
};
#endif

#ifndef SOAP_TYPE_xmlns__Axes
#define SOAP_TYPE_xmlns__Axes (75)
/* xmlns:Axes */
class SOAP_CMAC xmlns__Axes
{
public:
	int __size;	/* sequence of elements <Axis> */
	struct xmlns__Axis *Axis;	/* optional element of type xmlns:Axis */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_xmlns__Axes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Axes() { xmlns__Axes::soap_default(NULL); }
	virtual ~xmlns__Axes() { }
};
#endif

#ifndef SOAP_TYPE__Value
#define SOAP_TYPE__Value (79)
/* Value */
struct _Value
{
public:
	char *xsi__type;	/* optional attribute of type xsd:string */
	char *__v;
};
#endif

#ifndef SOAP_TYPE_xmlns__Cell
#define SOAP_TYPE_xmlns__Cell (78)
/* xmlns:Cell */
class SOAP_CMAC xmlns__Cell
{
public:
	char *CellOrdinal;	/* optional attribute */
	struct _Value Value;	/* required element of type Value */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_xmlns__Cell */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Cell() { xmlns__Cell::soap_default(NULL); }
	virtual ~xmlns__Cell() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__CellData
#define SOAP_TYPE_xmlns__CellData (80)
/* xmlns:CellData */
class SOAP_CMAC xmlns__CellData
{
public:
	int __size;	/* sequence of elements <Cell> */
	xmlns__Cell *Cell;	/* optional element of type xmlns:Cell */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_xmlns__CellData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__CellData() { xmlns__CellData::soap_default(NULL); }
	virtual ~xmlns__CellData() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__root
#define SOAP_TYPE_xmlns__root (82)
/* xmlns:root */
class SOAP_CMAC xmlns__root
{
public:
	xmlns__OlapInfo *OlapInfo;	/* optional element of type xmlns:OlapInfo */
	xmlns__Axes *Axes;	/* optional element of type xmlns:Axes */
	xmlns__CellData *CellData;	/* optional element of type xmlns:CellData */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_xmlns__root */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__root() { xmlns__root::soap_default(NULL); }
	virtual ~xmlns__root() { }
};
#endif

#ifndef SOAP_TYPE_cxmla__executeReturn
#define SOAP_TYPE_cxmla__executeReturn (86)
/* cxmla:executeReturn */
class SOAP_CMAC cxmla__executeReturn
{
public:
	xmlns__root root;	/* required element of type xmlns:root */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_cxmla__executeReturn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         cxmla__executeReturn() { cxmla__executeReturn::soap_default(NULL); }
	virtual ~cxmla__executeReturn() { }
};
#endif

#ifndef SOAP_TYPE_xmlns__Command
#define SOAP_TYPE_xmlns__Command (87)
/* xmlns:Command */
class SOAP_CMAC xmlns__Command
{
public:
	char *Statement;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_xmlns__Command */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmlns__Command() { xmlns__Command::soap_default(NULL); }
	virtual ~xmlns__Command() { }
};
#endif

#ifndef SOAP_TYPE_cxmla__ExecuteResponse
#define SOAP_TYPE_cxmla__ExecuteResponse (88)
/* cxmla:ExecuteResponse */
class SOAP_CMAC cxmla__ExecuteResponse
{
public:
	char *xmlns;	/* optional attribute */
	cxmla__executeReturn cxmla__return__;	/* required element of type cxmla:executeReturn */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_cxmla__ExecuteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         cxmla__ExecuteResponse() { cxmla__ExecuteResponse::soap_default(NULL); }
	virtual ~cxmla__ExecuteResponse() { }
};
#endif

#ifndef SOAP_TYPE_BSessionType
#define SOAP_TYPE_BSessionType (90)
/* BSessionType */
struct BSessionType
{
public:
	char *xmlns;	/* optional attribute of type xsd:string */
	char *element;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SessionType
#define SOAP_TYPE_SessionType (92)
/* SessionType */
struct SessionType
{
public:
	char *SessionId;	/* optional attribute of type xsd:string */
	char *xmlns;	/* optional attribute of type xsd:string */
	char *element;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ESessionType
#define SOAP_TYPE_ESessionType (94)
/* ESessionType */
struct ESessionType
{
public:
	char *SessionId;	/* optional attribute of type xsd:string */
	char *xmlns;	/* optional attribute of type xsd:string */
	char *element;	/* optional element of type xsd:string */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (89)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	struct BSessionType *BeginSession;	/* optional element of type BSessionType */
	struct SessionType *Session;	/* optional element of type SessionType */
	struct ESessionType *EndSession;	/* optional element of type ESessionType */
};
#endif

#endif

#ifndef SOAP_TYPE_xmlns__Discover
#define SOAP_TYPE_xmlns__Discover (98)
/* xmlns:Discover */
struct xmlns__Discover
{
public:
	char *RequestType;	/* optional element of type xsd:string */
	xmlns__Restrictions Restrictions;	/* required element of type xmlns:Restrictions */
	xmlns__Properties Properties;	/* required element of type xmlns:Properties */
};
#endif

#ifndef SOAP_TYPE_xmlns__Execute
#define SOAP_TYPE_xmlns__Execute (101)
/* xmlns:Execute */
struct xmlns__Execute
{
public:
	char *RequestType;	/* optional element of type xsd:string */
	xmlns__Command Command;	/* required element of type xmlns:Command */
	xmlns__Properties Properties;	/* required element of type xmlns:Properties */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (102)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (104)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (106)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (107)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (7)
typedef char *xsd__string;
#endif

#ifndef SOAP_TYPE_xsd__bool
#define SOAP_TYPE_xsd__bool (9)
typedef bool xsd__bool;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
